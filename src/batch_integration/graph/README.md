# Batch Integration with Graph Output

The output of all batch integration tasks can be represented as a graph. This sub-task focuses on all methods that can
output integrated graphs, and includes methods that canonically output the other two data formats with subsequent
postprocessing to generate a graph. Other sub-tasks for batch integration can be found for:

* [embeddings](../embedding/), and
* [corrected features](../feature/)

This sub-task was taken from
a [benchmarking study of data integration methods](https://www.biorxiv.org/content/10.1101/2020.05.22.111161v2).

## API

### Input

Datasets should contain the following attributes:

* `adata.uns['name']`: name of the dataset
* `adata.obs['batch']` with the batch covariate
* `adata.obs['label']` with the cell identity label
  * `adata.var['highly_variable']`: label whether a gene is identified as highly variable
* `adata.layers['counts']` with raw, integer UMI count data
* `adata.layers['logcounts']`: log-normalized count data
* `adata.layers['logcounts_scaled']`: scaled log-normalized count data
* `adata.obsm['X_uni']`: PCA embedding of the log-normalized counts
* `adata.uns['uni']`: neighbors data generated by `scanpy.pp.neighbors()`
* `adata.obsp['uni_connectivities']`: connectivity matrix generated by `scanpy.pp.neighbors()`
* `adata.obsp['uni_distances']`: distance matrix generated by `scanpy.pp.neighbors()`

The default count matrix in `adata.X` is assumed to contain the log normalised counts from `adata.layers['logcounts']`.

### Output

For each integration method, the count matrix can be used as-is, feature selected for highly variable genes (HVGs)
and/or scaled to unit variance and zero mean.
As a result, there are four different preprocessing scenarios per dataset
and method that include scaling and HVG selection:

* `full_unscaled`: no HVG selection or scaling
* `hvg_unscaled`: HVG selected
* `full_scaled`: scaled
* `hvg_scaled`: HVG selected and scaled

The user should be able to specify which of the four scenarios to run the method with.

Methods should assign integration output to:

* `adata.obsp['connectivities']` and `adata.obsp['distances']`

Metrics can compare:

* `adata.obsp['connectivities']` to `adata.obs['uni_connectivies']`,
* `adata.obsp['connectivities']` to `adata.obs['label']`, and/or
* `adata.obsp['connectivities']` to `adata.obs['batch']`.
